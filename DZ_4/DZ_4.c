#include <stdio.h>
#include <string.h>
#define SIZE 20 //Хранит размер массивов строк
#define MAXBK 100//Хранит размер телефонного справочника
struct abonent {
	char name[SIZE];
	char second_name[SIZE];
	char tel[SIZE];
	int control;//Переменная для индикации о заполненности элементов массива структур
};              //control = 0 - элемент массива доступен для записи нового абонента
//control = 1 - элемент массива уже занят абонентом
const char* start[5] = { //Массив указателей на строки для вывода меню возможных действий
	"1) Добавить абонента",
	"2) Удалить абонента",
	"3) Поиск абонента по имени",
	"4) Вывести всё содержимое справочникиа",
	"5) Завершение программы"
};
char* s_gets(char* str, int str_sz);//Прототип ф-ии для ввода строки
int prv_sum(struct abonent* mas, int mas_sz);//Прототип ф-ии для контроля заполненности массива структур
void add_ab(struct abonent* mas, int mas_sz);//Прототип ф-ии для добавления абонента в справочник
void del_ab(struct abonent* mas, int mas_sz);//Прототип ф-ии для удаления абонента из справочника
void srch_ab(struct abonent* mas, int mas_sz);//Прототип ф-ии для поиска абонента
void all_ab(struct abonent* mas, int mas_sz);//Прототип ф-ии для поиска абонента

int main() {
	struct abonent book[MAXBK];//Объявление массива структур
	int n = 0;//Вводимое значение для выбора действий из меню.
	for (int i = 0; i < MAXBK; i++) {//Цикл для заполнение индикатора control нолями.
		book[i].control = 0; //В начале программы все элементы массива доступны доя записи.
	}
	printf("%s\n%s\n%s\n%s\n%s\n", start[0], start[1], start[2], start[3], start[4]);//Вывод меню дейтвий на экран.

	while (n != 5) {//Основной цикл программы, елси пользователь введёт n = 5, программа завершается.
		printf("Выберите действие: ");
		//Проверка на корретность ввода
		if (scanf("%d", &n) != 1 || (n > 5) || (n < 0)) {
			printf("Введён некорректный запрос, попробуйте ещё раз\n");
			//Очистка буфера, после некорретного ввода
			while (getchar() != '\n')
				continue;
		}
		else {
			//Очистка буфера от символа новой строки \n, оставшегося после scanf().
			while (getchar() != '\n');
			//Пользователь ввёл 1 - добавление абонента
			if (n == 1) {
				//Проверка справочника на заполненность, вызов ф-ии суммирующей значения control в массиве
				if (prv_sum(book, MAXBK) == MAXBK) {
					printf("Память заполнена, выберите другое действие\n");
				}
				//Если в справочнике есть место, вызов ф-ии для доб-ия абонента
				else {
					add_ab(book, MAXBK);
				}
			}
			//Пользователь ввёл 2 - удаление абонента.
			if (n == 2) {
				//Вызов ф-ии для удаления абонента
				del_ab(book, MAXBK);
			}
			//Пользователь ввёл 3 - поиск абонента по имени.
			if (n == 3) {
				//Вызов ф-ии для поиска абонента
				srch_ab(book, MAXBK);
			}
			//Пользователь ввёл 4 - вывод всего содержимого справочника.
			if (n == 4) {
				if (prv_sum(book, MAXBK) == 0) {//Проверка справочника на заполненность
					printf("Результат: справочник пуст\n");
				}
				//Если справочник не пуст вызов ф-ии для вывода всего содержимого справочника
				else {
					all_ab(book, MAXBK);
				}
			}
			//Пользователь ввёл 5 - выход из программы
			if (n == 5) {
				printf("Программа завершена");
			}
		}
	}
	return 0;
}

//Ф-ия для добавления абонента в справочник
void add_ab(struct abonent* mas, int mas_sz) {
	//С помощью цикла ищется первый свободный слот (control = 0) для записи абонента
	for (int i = 0; i < mas_sz; i++) {
		if (mas[i].control == 0) {
			printf("Введите имя: ");
			s_gets(mas[i].name, SIZE);
			printf("Введите фамилию: ");
			s_gets(mas[i].second_name, SIZE);
			printf("Введите номер телефона: ");
			s_gets(mas[i].tel, SIZE);
			mas[i].control = 1;// в control записвается 1, для индикации того, что дананя структура массива заполненна
			printf("Абонент добавлен в справочник\n");
			break;             
		}
	}
}

//Ф-ия для удаления абонента из справочника
void del_ab(struct abonent* mas, int mas_sz) {
	char d_name[SIZE]; //Строка для ввода поиска имени, удаляемого абонента.
	char d_sname[SIZE];//Строка для ввода поиска фамили, удаляемого абонента.
	int cnt_d = 0;//Счётчик для контроля поиска.
	printf("Введите имя: ");
	s_gets(d_name, SIZE);
	printf("Введите фамилию: ");
	s_gets(d_sname, SIZE);
	//Цикл для прохода по элементам массива(справочника)
	for (int i = 0; i < mas_sz; i++) {
		//Абонент найден, если совпали имя и фамилия и в индикаторе control = 1 (т.е. структура считается заполненной).
		if ((strcmp(mas[i].name, d_name) == 0) && (strcmp(mas[i].second_name, d_sname) == 0) && (mas[i].control == 1)) {
			mas[i].control = 0;//В индикатор control записывается 0 (т.е. считаем, что структура пуста)
			printf("Абонент удалён из справочника\n");
			cnt_d++;//Увеличение счётчика, при успешном поиске
		}
	}
	if (cnt_d == 0) {//Если значение счётчика не изменилось, значит совпадений не найдено
		printf("Введённый абонент не найден\n");
	}
}

//Ф-ия для поиска абонента
void srch_ab(struct abonent* mas, int mas_sz) {
	char s_name[SIZE];//Строка для имени абонента, которого будем искать.
	printf("Введите имя: ");
	s_gets(s_name, SIZE);
	int cnt_s = 0;//Счётчик для контроля поиска.
	//Цикл для прохода по элементам массива (справочника)
	for (int i = 0; i < mas_sz; i++) {
		//Абонент найден, если совпало имя и в индикаторе control = 1 (т.е. структура считается заполненной).
		if ((strcmp(mas[i].name, s_name) == 0) && (mas[i].control == 1)) {
			printf("Результат: %s %s %s\n", mas[i].name, mas[i].second_name, mas[i].tel);
			cnt_s++;//Увеличение счётчика, при успешном поиске
		}
	}
	if (cnt_s == 0) {//Если значение счётчика не изменилось, значит совпадений не найдено
		printf("Введённый абонент не найден\n");
	}
}

//Ф-ия для вывода на экран всех абонентов справочника
void all_ab(struct abonent* mas, int mas_sz) {
	printf("Результат:\n");
	//Цикл для прохода по элементам массива(справочника)
	for (int i = 0; i < mas_sz; i++) {
		if (mas[i].control == 1) {//Если в индикаторе control записана 1 значит в структуре хранится абонент
			//Вывод данных абонента на экран
			printf("%s %s %s\n", mas[i].name, mas[i].second_name, mas[i].tel);
		}
	}
}

//Ф-ия для корректной обработик строк. Принимает указатель на строку и размер строки
char* s_gets(char* str, int str_sz) {
	char* result;//Указатель, который будет хранить результат выполнения ф-ии.
	char* find;//Указатель, который будет хранить результат ф-ии посика символа в строке.
	result = fgets(str, str_sz, stdin);
	if (result != NULL) {//Проверка условия того, что строка введена без ошибок.
		find = strrchr(str, '\n');//Поиск символа новой строки в введённой строке.
		if (find != NULL) {//Если символ новой строки найден
			*find = '\0';//на его место записывается символ окончания строки.
		}
		else {//Если символ новой строки не найден, значит было введено кол-во символов превышающее размер строки.
			while (getchar() != '\n') {//Очистка буфера от лишних символов, пока не встретится символ новой строки.

			}
		}
	}
	return result;
}

//Ф-ия для проверки заполненности справочника. Она проходится по элементам массива структур,
//суммируя значения записанные в индикаторе control (0 либо 1), возвращает сумму.
int prv_sum(struct abonent* mas, int mas_sz) {
	int res = 0;
	for (int i = 0; i < mas_sz; i++) {
		res += mas[i].control;
	}
	return res;
}